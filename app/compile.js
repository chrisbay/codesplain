const path = require('path');
const fs = require('fs-promise');
const child_process = require('child-process-promise');
const antlr = require('antlr4');

const config = require('../config.js');
const expect_error = require('./expect_error.js');
const tree_matcher = require('./tree_matcher.js');
const java_func_data_generator = require('./java_func_data_generator.js');

const array_diff = (a, b) => a.filter(i => b.indexOf(i) === -1);

const resolve_grammar_path = (lang_key, grammar_file) =>
      path.resolve(__dirname, '..', 'grammars-v4', lang_key, grammar_file);

// Throws an error if the generated parser does not have same
// rules as the specified config file.
const ensure_rules_match = (lang_runtime_config) => {
  const {
    language,
    rules,
  } = lang_runtime_config;

  // Create instance of the parser
  const parser_classname = language + 'Parser';
  const ParserClass = require(`${cache_dir}/${parser_classname}.js`)[parser_classname]
  const parser = new ParserClass();

  // Create an array of symbol (terminal) names
  const symbol_name_map = ['_EPSILON', '_EOF', '_INVALID']
      .concat(parser.symbolicNames.slice(1))
      .map((val) => val ? '.' + val : undefined);

  // Create the lists of rule names (both terminals and non-terminals)
  const parser_rules = parser.ruleNames.concat(symbol_name_map.filter(Boolean));
  const config_rules = Object.keys(rules);

  // Make sure the parser doesn't have extra rules
  const config_missing = array_diff(parser_rules, config_rules);
  if (config_missing.length) {
      throw new Error('Missing rules ' + JSON.stringify(config_missing));
  }

  // Make sure our config doesn't have extra rules
  const config_extra = array_diff(config_rules, parser_rules);
  if (config_extra.length) {
      throw new Error('Extra rules ' + JSON.stringify(config_extra));
  }

  return { symbol_name_map, parser };
}

const generate_runtime_config_modifier = (
  lang_compile_config,
  lang_runtime_config,
  symbol_name_map,
  parser
) => {
  // Turns these maps into human-readable JSON for insertion
  // into returned function string
  const symbol_name_map = JSON.stringify(symbol_name_map, null, 2);
  const rule_name_map   = JSON.stringify(parser.ruleNames, null, 2);

  const { tree_matcher_specs } = lang_compile_config;
  let tree_matchers;
  if (tree_matcher_specs) {
    const generator = await tree_matcher.make_generator(
      lang_compile_config,
      lang_runtime_config
    );
    tree_matchers = tree_matcher_specs.map(generator);
  }

  // Return the runtime config modifier - a function that
  // modifies the lang_runtime_config
  return `
  /*
  This function is generated by app/compile.js
  Do not attempt to make changes. They will be overwritten.
  */
  module.exports = function(lang_runtime_config) {
    lang_runtime_config.symbol_name_map = ${symbol_name_map};
    lang_runtime_config.rule_name_map   = ${rule_name_map};
    ${
      // Add a tree matcher function if appropriate too
      tree_matcher_specs ?
      `lang_runtime_config.tree_matcher = function(root) {
        ${tree_matchers.join('\n')}
      };`
      :
      '';
    }
  };
  `;
}

// Invokes the antlr process. Returns a Promise.
const invokeAntlr = (lang_runtime_config, cache_dir) => {
  const {
    language,
    generate_visitor,
    generate_listener,
  } = lang_runtime_config;

  // Prepare options to the antlr compiler that generates
  // the antlr lexer and antlr parser
  const cmd = 'java';
  const args = [
      '-Xmx500M',
      '-cp', '../../bin/antlr-4.6-complete.jar',
      'org.antlr.v4.Tool',
      '-long-messages',
      generate_listener ? '-listener' : '-no-listener',
      generate_visitor ? '-visitor' : '-no-visitor',
      '-Dlanguage=JavaScript',
      language + '.g4',
  ];
  const opts = {
      'cwd': cache_dir,
      'stdio': ['ignore', process.stdout, process.stderr],
  };

  return child_process.spawn(cmd, args, opts);
}

module.exports = (lang_compile_config, lang_runtime_config) => {
    // Figure out the language key
    const language_key = lang_runtime_config.language.toLowerCase();

    // Figure out the path to the grammar file
    const {
      grammar_path,
      grammar_file,
      needs_java_func_data,
    } = lang_compile_config;

    const g4_path = grammar_path ? grammar_path :
      resolve_grammar_path(language_key, grammar_file);

    // Figure out the path to the cache directory
    const cache_dir     = config.resolve_cache_dir(lang_runtime_config);
    const cache_g4_path = path.resolve(cache_dir, language + '.g4');

    const compile_promise = async () => {
      const on_eexist_err = expect_error('EEXIST', () => {});

      // Make sure the cache directory exists
      await fs.mkdir(config.cache_path).catch(on_eexist_err);

      // Make sure the language cache directory exists
      await fs.mkdir(cache_dir).catch(on_eexist_err);

      // Copies the g4 file into the cache directory
      await fs.copy(g4_path, cache_g4_path);

      await invokeAntlr(lang_runtime_config, cache_dir);

      if (needs_java_func_data) {
        await fs.stat(config.cache_path + '/java_func_data')
            .catch(expect_error('ENOENT', java_func_data_generator));
      }

      const {
        symbol_name_map,
        parser
      } = ensure_rules_match(lang_runtime_config);

      const runtime_config_modifier = generate_runtime_config_modifier(
        lang_compile_config,
        lang_runtime_config,
        symbol_name_map,
        parser
      );

      // Write the runtime config modifier
      const modifier_path = path.resolve(cache_dir, 'runtime_config_modifier.js');
      await fs.writeFile(modifier_path, runtime_config_modifier);
    };

    // Check if the cache directory exists using 'stat'
    return fs.stat(cache_dir)
      // If it does not exist, then build it up using compile_promise().
      .catch(expect_error('ENOENT', compile_promise))
      // In either case, return an object describing the results.
      // Currently, this description is just where the compiled files are stored.
      .then(() => ({ cache_dir }));
};
