const path = require('path');
const fs = require('fs-promise');
const antlr = require('antlr4');
const expect_error = require('../../utils/expect_error.js');
const run_antlr = require('../../utils/run_antlr.js');
const run_java = require('../../utils/run_java.js');

const cache_dir = '/tmp/codesplain/';

const genTreeViaJava = async function(lang_compile_config, lang_runtime_config, code) {
  const {
    build_dir
  } = await run_antlr(lang_compile_config, lang_runtime_config, 'Java');

  const java_sources = [
    lang_runtime_config.language + 'Lexer.java',
    lang_runtime_config.language + 'Parser.java',
  ];

  // Add CLASSPATH to environment
  const environment = Object.create(process.env);
  let classpath = environment.CLASSPATH ? environment.CLASSPATH.split(':') : [];
  classpath.unshift(path.resolve(__dirname, '../../bin/antlr-4.6-complete.jar'));
  classpath.unshift('.');
  environment.CLASSPATH = classpath.join(':');

  let result = await run_java(
    java_sources,
    'org.antlr.v4.gui.TestRig',
    [lang_runtime_config.language, lang_runtime_config.entry_rule, '-tree'],
    {
      'cwd': build_dir,
      'env': environment,
      //'stdio': ['pipe', 'pipe', process.stderr],
    },
    code
  );

  console.log(result.stderr.toString());
  return result.stdout.toString();
};

const genTreeViaJs = async function(lang_compile_config, lang_runtime_config, code) {
  const {
    build_dir
  } = await run_antlr(lang_compile_config, lang_runtime_config, 'JavaScript');

  let lexer_classname = lang_runtime_config.language + 'Lexer';
  let parser_classname = lang_runtime_config.language + 'Parser';

  // Loads the lexer and parser class generated by the antlr compiler.
  let LexerClass = require(build_dir + '/' + lexer_classname + '.js')[lexer_classname];
  let ParserClass = require(build_dir + '/' + parser_classname + '.js')[parser_classname];

  // Take the string of code, and generate a stream of tokens using the antlr lexer.
  // Example: ['if', '(', 'var', '==', '123', ')', '{', ...]
  let chars = new antlr.InputStream(code);
  let lexer = new LexerClass(chars);
  let tokens = new antlr.CommonTokenStream(lexer);

  // Take the stream of tokens, and create a parser class using the antlr parser.
  // Doesn't execute it yet.
  let parser = new ParserClass(tokens);

  // I don't know what this does
  parser.buildParseTrees = true;

  // Execute the parser and generate a tree.
  // This tree has complicated nodes that need to be simplified by our process_node function.
  let tree = parser[lang_runtime_config.entry_rule]();

  return tree.toStringTree(parser);
};

const compare = async function(language_name, code_file) {
  const lang_compile_config = require(`../../language_configs/${language_name}.compile.js`);
  const lang_runtime_config = require(`../../language_configs/${language_name}.runtime.js`);
  const code = await fs.readFile(code_file);
  const treeViaJava = await genTreeViaJava(lang_compile_config, lang_runtime_config, code);
  console.log('abc');
  const treeViaJs = await genTreeViaJs(lang_compile_config, lang_runtime_config, code);
  console.log('def');
  return treeViaJava === treeViaJs;
};


const prev_timeout = jasmine.getEnv().DEFAULT_TIMEOUT_INTERVAL;
jasmine.getEnv().DEFAULT_TIMEOUT_INTERVAL = 20000;

describe('grammars-v4/', () => {
  describe('grammars-v4/java8/', () => {
    it(`handles basic hello worlds`, () => {
      return compare('java8', __dirname + '/code/snippet.0.java').then(data => {
        expect(data).toBeTruthy();
      });
    });
  });

  describe('grammars-v4/java8/', () => {
    it(`tags for range loops`, () => {
      return compare('python3', __dirname + '/code/snippet.1.py').then(data => {
        expect(data).toBeTruthy();
      });
    });
  });
});

jasmine.getEnv().DEFAULT_TIMEOUT_INTERVAL = prev_timeout;
