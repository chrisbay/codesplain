const path = require('path');
const fs = require('fs-promise');
const antlr = require('antlr4');
const expect_error = require('../../src/utils/expect_error.js');
const run_antlr = require('../../src/utils/run_antlr.js');
const run_java = require('../../src/utils/run_java.js');
const webpack = require('webpack');

const config = require('../../config');

const genTreeViaJava = async function(lang_compile_config, lang_runtime_config, code) {
  return 'abc';
  const {
    build_dir
  } = await run_antlr(lang_compile_config, lang_runtime_config, 'Java');

  const java_sources = [
    lang_runtime_config.language + 'Lexer.java',
    lang_runtime_config.language + 'Parser.java',
  ];

  // Add CLASSPATH to environment
  const environment = Object.create(process.env);
  const classpath = environment.CLASSPATH ? environment.CLASSPATH.split(':') : [];
  classpath.unshift(path.resolve(__dirname, '../../bin/antlr-4.6-complete.jar'));
  classpath.unshift('.');
  environment.CLASSPATH = classpath.join(':');

  const result = await run_java(
    java_sources,
    'org.antlr.v4.gui.TestRig',
    [lang_runtime_config.language, lang_runtime_config.entry_rule, '-tree'],
    {
      'cwd': build_dir,
      'env': environment,
      //'stdio': ['pipe', 'pipe', process.stderr],
    },
    code
  );

  console.log(result.stderr.toString());
  return result.stdout.toString();
};

const genTreeViaJs = async function(lang_compile_config, lang_runtime_config, code) {
  const output_path = path.resolve(config.build_path, 'output');

  const webpack_config = await require('../../webpack.config.js')({
    'langs': lang_runtime_config.language,
    'optimize': 0,
    'libraryTarget': 'commonjs2',
    'outputPath': output_path,
    'enable_debug': true,
  });

  const compiler = webpack(webpack_config);
  await new Promise(function(resolve, reject) {
    compiler.run(function(err, stats) {
      if (err) {
        reject(err);
      } else {
        resolve(stats);
      }
    });
  });

  const parser = require(path.resolve(output_path, lang_runtime_config.language));

console.log('code start');
  const string_tree = parser(code, function(err) {
    throw err;
  }, {
    'return_toStringTree': true,
  });
  console.log('code end');

  return string_tree;

/*
  const {
    build_dir
  } = await run_antlr(lang_compile_config, lang_runtime_config, 'JavaScript');

  let lexer_classname = lang_runtime_config.language + 'Lexer';
  let parser_classname = lang_runtime_config.language + 'Parser';

  // Loads the lexer and parser class generated by the antlr compiler.
  let LexerClass = require(build_dir + '/' + lexer_classname + '.js')[lexer_classname];
  let ParserClass = require(build_dir + '/' + parser_classname + '.js')[parser_classname];

  // Take the string of code, and generate a stream of tokens using the antlr lexer.
  // Example: ['if', '(', 'var', '==', '123', ')', '{', ...]
  let chars = new antlr.InputStream(code);
  let lexer = new LexerClass(chars);
  let tokens = new antlr.CommonTokenStream(lexer);

  // Take the stream of tokens, and create a parser class using the antlr parser.
  // Doesn't execute it yet.
  let parser = new ParserClass(tokens);

  // I don't know what this does
  parser.buildParseTrees = true;

  // Execute the parser and generate a tree.
  // This tree has complicated nodes that need to be simplified by our process_node function.
  let tree = parser[lang_runtime_config.entry_rule]();

  return tree.toStringTree(parser);
*/
};

const compare = async function(language_name, code_file) {
  const lang_compile_config = require(`../../language_configs/${language_name}.compile.js`);
  const lang_runtime_config = require(`../../language_configs/${language_name}.runtime.js`);
  const code = await fs.readFile(code_file, {'encoding': 'utf8'});
  const treeViaJava = await genTreeViaJava(lang_compile_config, lang_runtime_config, code);
  console.log(treeViaJava);
  const treeViaJs = await genTreeViaJs(lang_compile_config, lang_runtime_config, code);
  console.log(treeViaJs);
  return treeViaJava === treeViaJs;
};



const prev_timeout = jasmine.getEnv().DEFAULT_TIMEOUT_INTERVAL;
jasmine.getEnv().DEFAULT_TIMEOUT_INTERVAL = 20000;

describe('grammars-v4/', () => {
  afterAll(() => {
    fs.unlink(config.build_path);
  });

  describe('grammars-v4/java8/', () => {
    it(`handles basic hello worlds`, () => {
      return compare('java8', __dirname + '/code/snippet.0.java').then(data => {
        expect(data).toBeTruthy();
      });
    });
  });
/*
  describe('grammars-v4/java8/', () => {
    it(`handles basic hello worlds`, () => {
      return compare('python3', __dirname + '/code/snippet.1.py').then(data => {
        expect(data).toBeTruthy();
      });
    });
  });
*/
});

jasmine.getEnv().DEFAULT_TIMEOUT_INTERVAL = prev_timeout;
